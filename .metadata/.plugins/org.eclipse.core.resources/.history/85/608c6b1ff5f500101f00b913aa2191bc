package com.bazotech.store.controllers; 


import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Errors;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.SessionAttributes;
import com.bazotech.store.domain.*;
import com.bazotech.store.domain.Part.Type;


import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.Enumeration;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Controller
@RequestMapping("/design")
@SessionAttributes("tacoOrder") // keep the value associated with the key tacoOrder existing across different sessions.
public class DesignTacoController {
	
	//private final IngredientRepository ingredientRepo;
	
	//@Autowired
	// DesignTacoController(IngredientRepository ingredientRepo) {
	//	this.ingredientRepo = ingredientRepo;
	//}
	
	
	/* Spring processes this method before calling any request handler methods. */
	@ModelAttribute
	public void addIngredientsToModel(Model model) { /** Start Method Definition **/
		
		/* creating a list of ingredients */
		
		List<Part> ingredients = Arrays.asList(
				new Part("FLTO", "Flour Tortilla"		, Part.Type.WRAP),
				new Part("COTO", "Corn Tortilla" 		, Part.Type.WRAP),
				new Part("GRBF", "Ground Beef"   		, Part.Type.PROTEIN),
				new Part("CARN", "Carnitas"        	, Part.Type.PROTEIN),
				new Part("TMTO", "Diced Tomatoes"		, Part.Type.VEGGIES),
				new Part("LETC", "Lettuce"			, Part.Type.VEGGIES),
				new Part("CHED", "Cheddar"			, Part.Type.CHEESE),
				new Part("JACK", "Monterrey Jack"		, Part.Type.CHEESE),
				new Part("SLSA", "Salsa"				, Part.Type.SAUCE),
				new Part("SRCR", "Sour Cream"			, Part.Type.SAUCE)
		);
		
		
		//Iterable<Ingredient> ingredients = ingredientRepo.findAll();
		
		/* create an array of types.*/
		Type[] types = Part.Type.values();
		
		
		/* Add to the model a filtered list of ingredients for each type.*/
		for(Type type:types) {
			model.addAttribute(type.toString().toLowerCase(),filterByType((List<Part>) ingredients, type));
		}
		
		
	} /** End Method addIngredientsToModel **/
	
	
	
	
	/* Helper method to filter ingredients by type. */
	private Iterable<Part> filterByType(List<Part> ingredients, Type type) {
		return ingredients
				.stream()
				.filter(ingredient -> ingredient.getType().equals(type))
				.collect(Collectors.toList());
	}
		
	
	/* Add the tacoOrder object to the model if it does not already exist in the model.*/
	@ModelAttribute(name="tacoOrder")
	public ProductOrder tacoOrder() {
		return new ProductOrder();
	}
	
	
	
	/* Add the taco object to the model if it does not already exist in the model.*/
	@ModelAttribute(name="taco")
	public Product taco() {
		return new Product();
	}
	
	
	
	/* Method to handle GET requests for /design */
	@GetMapping
	public String showDesignForm() {
		return "design";
	}
	
	
	/* Processing the submitted form */
	@PostMapping
	public String processTaco(@Valid Product taco, Errors errors, @ModelAttribute ProductOrder tacoOrder,HttpServletRequest req, HttpServletResponse res) {
		/* if any errors are identified, stop processing and re-display the design form.*/
		if(errors.hasErrors()) {
			return "design";
		}
		
		taco.getIngredients().forEach(ingredient -> log.info("from converter: {}", ingredient));
		
		tacoOrder.addTaco(taco);
		// Logic to persist taco creations to the database comes here.
		log.info("Processing taco: {}", taco);
		//return "redirect:/";
		return "redirect:/orders/current";
		
	}

	
	
	
} // end class
