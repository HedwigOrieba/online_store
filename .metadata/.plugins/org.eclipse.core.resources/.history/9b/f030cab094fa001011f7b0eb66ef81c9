package com.bazotech.store.domain;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Builder
@Getter
@Setter
@ToString(exclude= {"products","storeItems","tags"})
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@Table(name="inventory_items")
@Entity
public class InventoryItem {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@EqualsAndHashCode.Include
	@Column(name="item_id", nullable=false)
	private Long itemId;
	
	@NotNull
	@ManyToOne(optional=false) 
	@JoinColumn(name="merchant_id", nullable=false) 
	private Merchant merchant; 
	
	@ManyToOne(optional=false) 
	@NotNull
	@JoinColumn(name="vendor_id", nullable=false) 
	private Vendor vendor;
	
	@NotNull
	@ManyToOne(optional=false)
	@JoinColumn(name="category_id", nullable=false)
	private ItemCategory category;
	
	@Column(name="created_on")
	private LocalDateTime createdOn;
	
	@PrePersist
	protected void onCreate() {
	    this.createdOn = LocalDateTime.now();
	}
	
	@NotNull
	@Column(name="item_name")
	private String itemName;
	
	@NotNull
	@Enumerated(EnumType.STRING)
	@Column(name="item_uom")
	private UomType itemUom;
	
	
	@NotNull
	@Min(value=0, message="Quantity must be non-negative")
	@Column(name="item_quantity")
	private Integer itemQuantity;
	
	
	@NotNull
	@Column(name="item_description")
	private String itemDescription;
	
	
	// Relationship with ItemBatch
	@Builder.Default
	@OneToMany(mappedBy = "inventoryItem", cascade = CascadeType.ALL, orphanRemoval = true) 
	private List<ItemBatch> batches = new ArrayList<>();
	
	public void addBatch(ItemBatch batch) { 
		if (!batches.contains(batch)) { 
			batches.add(batch); 
			batch.setInventoryItem(this); // keep the back-reference consistent 
			} 
	}
	
	// Helper method to remove a batch 
	public void removeBatch(ItemBatch batch) { 
		batches.remove(batch); 
		batch.setInventoryItem(null); // clear the back-reference 
	}

	
	
	
	
	/* linkage to client facing products. */
	@Builder.Default
	@OneToMany(mappedBy="inventoryItem", cascade=CascadeType.ALL, orphanRemoval=true)
	List<Product> products = new ArrayList<>();
	
	/* helper method for products collection */
	public void addProduct(Product product) {
		if (!products.contains(product)){
		    products.add(product);
		    product.setInventoryItem(this);
		}
	}

	
	public void removeProduct(Product product) { 
		products.remove(product); 
		product.setInventoryItem(null); 
	}
	
	/* Linkage to the stores */
	@Builder.Default
	@OneToMany(mappedBy="item", cascade=CascadeType.ALL, orphanRemoval=true)
	private List<StoreItem> storeItems = new ArrayList<>();

	/* helper method for the storeitems */
	public void addStoreItem(StoreItem storeItem) { 
		if (!storeItems.contains(storeItem)){
			storeItems.add(storeItem); 
			storeItem.setItem(this); 
		}
	} 
	
	public void removeStoreItem(StoreItem storeItem) { 
		storeItems.remove(storeItem); 
		storeItem.setItem(null); 
	}
	
	/* Linkage to tags*/
	@ManyToMany
	@Builder.Default
	@JoinTable( name="item_tag_map", 
	joinColumns=@JoinColumn(name="item_id"), inverseJoinColumns=@JoinColumn(name="tag_id") ) 
	private List<ItemTag> tags = new ArrayList<>(); 
	
	/* helper methods for the tags collection */
	public void addTag(ItemTag tag) {
		if (!tags.contains(tag)){
			tags.add(tag);
			tag.getItems().add(this);
		}
	}
	
	public void removeTag(ItemTag tag) {
		tags.remove(tag);
		tag.getItems().remove(this);
	}
	
	/* enum for the UOMs */
	public enum UomType{
		
		/* General */
		PIECE("Piece"),
		BOX("Box"),
		PACKET("Packet"),
		BAG("bag"),
		SACK("Sack"),
		CARTON("Carton"),
		BALE("Bale"), 
		PACKAGE("Package"),
		JERRYCAN("Jerrycan"),
		PALLET("Pallet"),
		CRATE("Crate"),
		BUNDLE("Bundle"),
		CONTAINER("Container"),
		TIN("Tin"),
		DOZEN("Dozen"),
		DRUM("Drum"),
		
		/* Weight */
		GRAM("Gram"),
		KILOGRAM("kilogram"),
		TONNE("Tonne"),
		
		/* Volume */
		LITER("Liter"),
		MILLILITER("Milliliter"),
		CUBIC_METER("Cubic Meter"),
		
		
		/* Length */
		MILLIMETER("Millimeter"),
		CENTIMETER("Centimeter"),
		METER("Meter"),
		KILOMETER("Kilometer"),
		INCH("Inch"),
		FOOT("Foot"),
		YARD("Yard"),
		
		/* Medical */
		MILLIGRAM("Milligram"),
		MICROGRAM("Microgram"),
		TABLET("Tablet"),
		CAPSULE("Capsule"),
		STRIP("Strip"),
		VIAL("Vial"),
		AMPULE("Ampule"),
		SYRINGE("Syringe"),
		BOTTLE("Bottle"),
		TUBE("Tube"),
		PATCH("Patch"),
		DROP("Drop"),
		SPRAY("Spray"),
		INHALER("Inhaler"),
		DOSE("Dose"),
		KIT("Kit"),
		POUCH("Pouch"), // powdered medicine
		SET("Set"),
		PAIR("Pair"),
		ROLL("Roll"),
		SHEET("Sheet"),
		TRAY("Tray"),
		UNIT("Unit"),
		CARTRIDGE("Cartridge"),
		SUTURE("SUTURE"),
		
		/* Raw Materials */
		BAR("Bar"),
		ROD("Rod"),
		COIL("Coil"),
		INGOT("Ingot"),
		BLOCK("Block"),
		
		/* Energy & Machine Output */
		KILOWATT_HOUR("Killowatt Hour"),
		CUBIC_METER_PER_HOUR("Cubic Meter per Hour"),
		LITER_PER_MINUTE("Liter per Minute"),
		CYCLE("Cycle"),
		RUN("Run"),
		SHIFT("Shift"),
		
		OTHER("Other");
		
		private final String label;
		
		UomType(String label){
			this.label = label;
		}
		
		public String getLabel() {
			return label;
		}
		
	}
	
}
